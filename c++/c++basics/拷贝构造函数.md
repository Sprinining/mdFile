## 拷贝构造函数

在 C++ 中，**拷贝构造函数（Copy Constructor）** 是一种特殊的构造函数，用于使用一个已有对象来初始化一个新对象。它的典型声明形式如下：

```cpp
ClassName(const ClassName& other);
```

### 示例

```cpp
#include <iostream>
using namespace std;

class Person {
public:
    string name;

    // 构造函数
    Person(string n) : name(n) {}

    // 拷贝构造函数
    Person(const Person& other) {
        cout << "拷贝构造函数调用" << endl;
        name = other.name;
    }
};

int main() {
    Person p1("Alice");
    Person p2 = p1; // 调用拷贝构造函数
    cout << p2.name << endl;
    return 0;
}
```

- **拷贝构造函数的第一个参数必须是“对自身类型的**`const`**引用”或“引用”**，不能是按值传递，否则会导致**无限递归调用（编译失败）**。
- 几乎所有正常使用场景下，拷贝构造函数的参数都是 `const T&`。
  - **支持 const 对象复制**： 如果不写 `const`，那 `MyClass obj2 = obj1;` 中如果 `obj1` 是 `const`，就不能调用 `MyClass(MyClass&)`。
  - **拷贝操作本质上不应修改源对象**： 加上 `const` 表示“拷贝源是只读的”，更安全、符合语义。
  - **和 STL、标准库兼容性更好**： 所有标准容器类、算法等内部实现都假设拷贝构造是 `const T&`。
- ==C++ 引用匹配规则==
  - **`const T&` 可以绑定到**：
    - 非 `const` 左值对象
    - `const` 左值对象
    - 临时值（右值）
  - **`T&`（非常量引用）只能绑定到**：
    - **非 `const` 左值对象**
    - **不能绑定 const 对象或临时对象**

### 拷贝构造函数调用时机

- 用一个对象初始化另一个对象（拷贝初始化）：`Person p2 = p1;`

- 将对象按值传递给函数时。

```cpp
class Person {
public:
    string name;

    Person(string n) : name(n) {}

    Person(const Person& other) {
        cout << "拷贝构造函数被调用" << endl;
        name = other.name;
    }
};

// 当 greet(a) 被调用时，a 会被拷贝一份，传给 p
// 在 greet 里面操作的是 a 的副本，不会影响 a 本身
void greet(Person p) {
    cout << "Hello " << p.name << endl;
}

int main() {
    Person a("Alice");
    greet(a);  // 这里会调用拷贝构造函数
}
```

- 从函数按值返回对象时。

```cpp
Person makePerson() {
    Person temp("Bob");
    return temp;  // 返回对象副本，会调用拷贝构造函数（或优化）
}

int main() {
    // 这个返回值会被拷贝到主函数中的变量 b
    Person b = makePerson();  // 这里也会调用拷贝构造函数（或优化）
}
```

### 合成拷贝构造函数

在 C++ 中，**合成拷贝构造函数（synthesized copy constructor）**是指编译器自动为一个类生成的拷贝构造函数，用于在对象复制时拷贝成员变量。其形式通常如下：

```cpp
ClassName(const ClassName& other);
```

#### 合成拷贝构造函数的生成条件

编译器会**在没有用户自定义拷贝构造函数**的前提下，自动合成一个拷贝构造函数，前提是：

- 所有成员变量的拷贝构造函数也都是可访问的；
  - 成员的拷贝构造是 `private`
  - 成员的拷贝构造是 `protected`，当前类不是子类或友元 
  - 成员类禁止拷贝（被 `delete`）
  - 私有成员类的拷贝构造是 `private`，但当前类不是它的友元
- 没有被 `= delete` 的特殊成员函数影响（例如：移动构造被删除，可能会影响是否合成等）；

| 成员函数             | 写/删/自定义后影响                 |
| -------------------- | ---------------------------------- |
| 拷贝构造（const T&） | 手写后，编译器不再自动生成移动构造 |
| 移动构造（T&&）      | 手写后，编译器不再自动生成拷贝构造 |
| 删除移动构造         | 拷贝构造仍然可以合成（只要合法）   |
| 删除拷贝构造         | 移动构造仍然可以合成（只要合法）   |

- 类中没有继承或成员是不可复制的对象。

| 类型                            | 是否可复制 | 说明                     |
| ------------------------------- | ---------- | ------------------------ |
| `std::mutex`                    | ❌          | 明确删除了拷贝构造和赋值 |
| 自定义类 `A(const A&) = delete` | ❌          | 手动禁用复制             |
| 继承自不可复制基类              | ❌          | 基类拷贝构造被删除或私有 |
| 含有以上类为成员或基类          | ❌          | 传播不可复制性           |

#### 合成拷贝构造函数的行为

- 对所有**非静态成员变量**执行**逐个拷贝（member-wise copy）**；
- 如果有基类，也会调用**基类的拷贝构造函数**；

示例：

```cpp
struct A {
    int x;
};

struct B {
    A a;
    int y;
    // 编译器会自动生成：
    // B(const B& other) : a(other.a), y(other.y) {}
};

void test() {
    B b1 = { {42}, 7 };
    B b2 = b1;  // 调用合成拷贝构造函数
}
```

#### 与默认关键字 `= default` 的关系

可以显示告诉编译器合成一个：

```cpp
struct C {
    int x;
    C(const C&) = default;  // 明确使用合成版本
};
```

也可以禁用：

```cpp
struct D {
    int x;
    D(const D&) = delete;  // 禁止拷贝构造
};
```

#### 注意事项

- 合成拷贝构造函数是**浅拷贝**，对指针成员变量只拷贝地址，不复制指针所指内容；
- 对于资源管理类（比如类中有 `new` 分配的内存），需要自己定义拷贝构造函数以防止**资源泄漏或双重释放**；
- 在 C++11 之后，如果自定义了**移动构造函数或移动赋值函数**，但没有提供拷贝构造，拷贝构造函数可能不会被自动合成。

#### 默认拷贝构造函数

| 名称             | 定义方式             | 本质行为 | 区别点                   |
| ---------------- | -------------------- | -------- | ------------------------ |
| 合成拷贝构造函数 | 什么都不写           | 浅拷贝   | 编译器隐式生成           |
| 默认拷贝构造函数 | `= default` 明确指定 | 浅拷贝   | 程序员显式要求编译器合成 |

### 自定义拷贝构造函数的典型用途

如果的类中包含**指针**或管理**动态资源（如内存、文件、网络句柄等）**，就应该自定义拷贝构造函数来实现**深拷贝（deep copy）**。

```cpp
class MyArray {
private:
    int* data;
    int size;

public:
    MyArray(int s) : size(s) {
        data = new int[size];
    }

    // 拷贝构造函数 - 深拷贝
    MyArray(const MyArray& other) : size(other.size) {
        data = new int[size];
        for (int i = 0; i < size; ++i)
            data[i] = other.data[i];
    }

    ~MyArray() {
        delete[] data;
    }
};
```

### 使用 `= delete` 禁用拷贝构造函数

如果希望对象**不可拷贝**，可以将拷贝构造函数禁用：

```cpp
class NonCopyable {
public:
    NonCopyable() = default;
    NonCopyable(const NonCopyable&) = delete; // 禁用拷贝构造
};
```

### 避免拷贝构造开销

#### 引用传参

默认传参是「值传递」，会调用拷贝构造函数。但如果用「**引用**」来传递参数，就不会拷贝。

```cpp
class Person {
public:
    string name;
    Person(string n) : name(n) {}

    Person(const Person& other) {
        cout << "拷贝构造函数调用" << endl;
        name = other.name;
    }
};

void greet(const Person& p) {  // 使用 const 引用避免拷贝
    cout << "Hello " << p.name << endl;
}

int main() {
    Person a("Alice");
    greet(a);  // 不会调用拷贝构造函数
}
```

为什么加 `const`？

- 防止函数修改 `a`。
- 允许函数接收临时对象（如 `greet(Person("Temp"))`）。
  - C++ 为了安全性，只允许把临时对象绑定到 `const T&`。
  - 不允许绑定到 `T&（非常量引用）`，因为不能修改临时对象。

#### 移动语义（C++11）

如果一个对象是**临时的**、马上就要销毁了，那就没有必要复制它的资源，而是可以“**移动**”它的资源到新对象中。

```cpp
class MyArray {
public:
    int* data;
    int size;

    MyArray(int s) : size(s) {
        data = new int[size];
        cout << "构造" << endl;
    }

    // 拷贝构造（深拷贝）
    MyArray(const MyArray& other) {
        cout << "拷贝构造" << endl;
        size = other.size;
        data = new int[size];
        for (int i = 0; i < size; ++i)
            data[i] = other.data[i];
    }

    // 移动构造函数（转移资源）
    MyArray(MyArray&& other) noexcept {
        cout << "移动构造" << endl;
        data = other.data;
        size = other.size;
        other.data = nullptr;  // 防止析构时重复释放
        other.size = 0;
    }

    ~MyArray() {
        delete[] data;
    }
};

MyArray createArray() {
    MyArray temp(10);  // 临时对象
    return temp;       // 会触发移动构造
}

int main() {
    MyArray a = createArray();  // 移动构造，而不是拷贝
}
```

移动构造 vs 拷贝构造

| 特性     | 拷贝构造函数           | 移动构造函数（C++11）    |
| -------- | ---------------------- | ------------------------ |
| 参数类型 | `const T&`             | `T&&`（右值引用）        |
| 复制行为 | 分配新资源并复制       | 把资源“转移”给新对象     |
| 性能     | 较慢（复制内容）       | 快（只是转移指针）       |
| 触发条件 | 对临时对象初始化新对象 | 优先触发（如果定义了它） |

### 聚合类型

**聚合类型（Aggregate Type）** 是 C++ 中一种非常特殊的类或结构体类型，它的设计目的就是为了**像数组一样**、**像 C 语言结构体一样**去初始化它 —— 不需要构造函数，不需要成员函数，所有成员按顺序初始化。这种类型在做 POD 类型、性能优化、序列化等低层场景非常有用。

#### 聚合类型的定义（标准描述，C++17）

在 C++17 中，一个**类类型**如果满足以下**所有条件**，就叫做 **聚合类型（aggregate）**：

1. **没有用户声明的构造函数（包括默认构造函数）**
2. **没有私有或受保护的非静态数据成员**
3. **没有虚函数**
4. **没有基类（继承）**
5. **没有使用 `= default` 明确声明的构造函数**
6. **没有虚基类**

从 C++20 起，标准略放宽了一些限制（比如允许 `base class` 也能是 aggregate）。

#### 举例说明

##### 聚合类型

```cpp
struct Point {
    int x;
    int y;
};
```

它是聚合类型，因为：

- 没有构造函数；
- 所有成员都是 public；
- 没有继承；
- 没有虚函数。

它可以用“聚合初始化”：

```cpp
Point p = {1, 2};  // ✅ 聚合初始化（按顺序初始化成员）
```

##### 非聚合类型（有构造函数）

```cpp
struct NotAggregate {
    int x;
    NotAggregate(int val) : x(val) {}
};
```

- 有用户声明的构造函数；
- 所以不是聚合类型；
- 不能 `NotAggregate obj = {1};`。

##### 非聚合类型（有继承）

```cpp
struct Base { int x; };
struct Derived : Base { int y; };  // ❌ 继承了 Base，不是聚合
```

在 **C++17** 中：不是聚合类型（因为继承）
 在 **C++20** 中：是聚合类型（继承被允许）

所以可以这样初始化：

```cpp
Derived d = {{1}, 2};  // 初始化 Base 的 x = 1，Derived 的 y = 2
```

#### 聚合类型的用途

| 用途                          | 说明                                         |
| ----------------------------- | -------------------------------------------- |
| 快速初始化                    | 可以像数组一样用 `{}` 初始化                 |
| 兼容 C 结构体（C 语言互操作） | 和 C 的 `struct` 一样                        |
| 避免构造开销 / constexpr 场景 | 比构造函数快、可以用在低层代码               |
| 标准库中的部分类型也用        | 如 `std::array<T, N>` 是聚合类型（C++20 起） |

### 初始化类型

#### 按语义分类（标准定义的初始化类型）

| 初始化方式                             | 简介说明                                                     | 示例                          |
| -------------------------------------- | ------------------------------------------------------------ | ----------------------------- |
| **默认初始化**default-initialization   | 用于未显式初始化的变量（如类成员或局部变量），是否被初始化取决于类型和上下文 | `int x;``MyClass obj;`        |
| **值初始化**value-initialization       | 初始化为“零”或调用默认构造函数，常用于 `T obj{};` 或 `T obj = T();` | `int x{};``T obj = T();`      |
| **拷贝初始化**copy-initialization      | 使用 `=` 语法进行初始化，允许调用拷贝构造、隐式类型转换等    | `T obj = other;`              |
| **直接初始化**direct-initialization    | 使用括号语法初始化，优先匹配构造函数                         | `T obj(arg);`                 |
| **列表初始化**list-initialization      | 使用花括号 `{}`，可以分为“直接列表初始化”和“拷贝列表初始化”  | `T obj{arg};``T obj = {arg};` |
| **聚合初始化**aggregate-initialization | 针对聚合类型，按成员顺序使用 `{}` 初始化，无需构造函数       | `Point p = {1, 2};`           |
| **零初始化**zero-initialization        | 所有字节置为 0，仅适用于静态存储对象或 `value-init` 时被用作子步骤 | `static int x;`               |
| **引用绑定初始化**reference binding    | 初始化引用，可能涉及临时对象绑定                             | `const T& ref = value;`       |

#### 按语法分类（写法维度）

| 写法                   | 所属初始化类型（可能）                   |
| ---------------------- | ---------------------------------------- |
| `T obj;`               | 默认初始化（局部变量）或零初始化（静态） |
| `T obj = value;`       | 拷贝初始化                               |
| `T obj(value);`        | 直接初始化                               |
| `T obj{};`             | 值初始化 / 直接列表初始化                |
| `T obj = {};`          | 值初始化 / 拷贝列表初始化                |
| `T obj = T();`         | 值初始化（经典 idiom）                   |
| `T obj = {a, b};`      | 拷贝列表初始化                           |
| `T obj{a, b};`         | 直接列表初始化                           |
| `T arr[] = {1, 2, 3};` | 聚合初始化（数组）                       |
| `MyStruct s = {1, 2};` | 聚合初始化（聚合类）                     |

#### 实用对比重点

| 关键点                       | 直接初始化 (`T obj(arg)`) | 拷贝初始化 (`T obj = arg`) | 列表初始化 (`{}`)               |
| ---------------------------- | ------------------------- | -------------------------- | ------------------------------- |
| 是否调用构造函数             | ✅                         | ✅                          | ✅（更严格）                     |
| 是否支持隐式转换             | ✅                         | ✅                          | 视情况而定                      |
| 是否允许 narrowing           | ✅                         | ✅                          | ❌ 会报错（如 `{3.14}` → `int`） |
| 是否支持 `explicit` 构造函数 | ✅                         | ❌                          | 直接 `{}` 可以，`=` 不行        |

```cpp
struct A {
    A(int) {}
    explicit A(double) {}
};

A a1 = 1;      // 拷贝初始化，调用 A(int)
A a2(1);       // 直接初始化，调用 A(int)
A a3 = 1.5;    // 拷贝初始化，调用 A(double)，但不能用 explicit！
A a4(1.5);     // 直接初始化，explicit 构造函数可用

A a5 = {1};    // 拷贝列表初始化（不能用 explicit）
A a6{1};       // 直接列表初始化（可用 explicit）
```

### 拷贝初始化

#### 拷贝初始化的语法形式

```cpp
T obj = expr;
```

- `T` 是目标对象类型
- `expr` 是用于初始化的表达式，可以是 `T` 类型的对象、其他类型的值、临时对象等

#### 拷贝初始化的工作机制

- 编译器会尝试使用 `expr` 通过隐式转换生成一个类型为 `T` 的临时对象（或直接就是 `T` 类型对象）
- 然后用这个临时对象调用 `T` 的拷贝构造函数（或移动构造函数）来初始化 `obj`
- 编译器允许通过隐式类型转换构造 `T` 对象，所以 `expr` 不必是 `T` 类型
- 现代编译器通常会进行**复制省略**（Copy Elision），优化掉临时对象，直接初始化 `obj`，避免调用拷贝构造

#### 拷贝初始化与直接初始化的区别

| 初始化方式 | 语法示例        | 是否允许调用 `explicit` 构造函数 | 是否调用拷贝构造函数                 |
| ---------- | --------------- | -------------------------------- | ------------------------------------ |
| 拷贝初始化 | `T obj = expr;` | 不允许                           | 通常会调用，但可能被省略             |
| 直接初始化 | `T obj(expr);`  | 允许                             | 不调用拷贝构造，直接调用对应构造函数 |
| 列表初始化 | `T obj{expr};`  | 允许                             | 不调用拷贝构造，调用对应构造函数     |

#### 拷贝初始化发生的时机

- 使用 `=` 定义变量
- 将一个对象作为实参传递给一个非引用类型的形参
- 从一个返回类型为非引用类型的函数返回一个对象
- 用花括号列表初始化一个数组中的元素或一个聚合类中的成员，也是拷贝初始化

#### 拷贝初始化为啥不能用explict?

- 本质原因：为了防止意外调用显式构造函数。
- `explicit` 的含义本身就是“**不允许隐式调用**”。而拷贝初始化（`T obj = arg;`）**是隐式初始化语法**。
- `直接初始化` 和 `直接列表初始化` 是“显式语法”，允许调用 `explicit` 构造函数。

#### 拷贝初始化一定会调用拷贝构造函数吗？

虽然**名字叫“拷贝初始化”**，但 **“拷贝初始化”并不总是调用拷贝构造函数**，它只是语法形式为 `T obj = something;` 的一种初始化方式，**实际调用什么构造函数、是否优化构造，全看上下文**。

可能的实际行为（几个典型场景）

| 场景                                      | 是否调用拷贝构造函数   | 说明                                            |
| ----------------------------------------- | ---------------------- | ----------------------------------------------- |
| `T obj = otherT;`（`otherT` 是 `T` 类型） | ✅ 是，调用拷贝构造     | 最常见的拷贝构造使用场景                        |
| `T obj = value;`（`value` 是其他类型）    | ❌ 否，可能调用转换构造 | 会寻找 `T::T(U)` 形式的构造函数（可能隐式转换） |
| `T obj = T(123);`                         | ❌ 否，可能被优化       | 编译器常常应用 **复制省略（copy elision）**     |
| `T obj = funcReturningT();`               | ❌ 否，可能被优化       | 如果启用了 NRVO（返回值优化），拷贝构造会被省略 |
| `T obj = {123};`（列表初始化）            | ❌ 否，使用花括号构造   | 这是**拷贝列表初始化**，不调用拷贝构造          |