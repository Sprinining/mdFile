## 拷贝构造函数

在 C++ 中，**拷贝构造函数（Copy Constructor）** 是一种特殊的构造函数，用于使用一个已有对象来初始化一个新对象。它的典型声明形式如下：

```cpp
ClassName(const ClassName& other);
```

### 示例

```cpp
#include <iostream>
using namespace std;

class Person {
public:
    string name;

    // 构造函数
    Person(string n) : name(n) {}

    // 拷贝构造函数
    Person(const Person& other) {
        cout << "拷贝构造函数调用" << endl;
        name = other.name;
    }
};

int main() {
    Person p1("Alice");
    Person p2 = p1; // 调用拷贝构造函数
    cout << p2.name << endl;
    return 0;
}
```

- **拷贝构造函数的第一个参数必须是“对自身类型的**`const`**引用”或“引用”**，不能是按值传递，否则会导致**无限递归调用（编译失败）**。
- 几乎所有正常使用场景下，拷贝构造函数的参数都是 `const T&`。
  - **支持 const 对象复制**： 如果不写 `const`，那 `MyClass obj2 = obj1;` 中如果 `obj1` 是 `const`，就不能调用 `MyClass(MyClass&)`。
  - **拷贝操作本质上不应修改源对象**： 加上 `const` 表示“拷贝源是只读的”，更安全、符合语义。
  - **和 STL、标准库兼容性更好**： 所有标准容器类、算法等内部实现都假设拷贝构造是 `const T&`。
- ==C++ 引用匹配规则==
  - **`const T&` 可以绑定到**：
    - 非 `const` 左值对象
    - `const` 左值对象
    - 临时值（右值）
  - **`T&`（非常量引用）只能绑定到**：
    - **非 `const` 左值对象**
    - **不能绑定 const 对象或临时对象**

### 拷贝构造函数调用时机

- 用一个对象初始化另一个对象（拷贝初始化）：`Person p2 = p1;`

- 将对象按值传递给函数时。

```cpp
class Person {
public:
    string name;

    Person(string n) : name(n) {}

    Person(const Person& other) {
        cout << "拷贝构造函数被调用" << endl;
        name = other.name;
    }
};

// 当 greet(a) 被调用时，a 会被拷贝一份，传给 p
// 在 greet 里面操作的是 a 的副本，不会影响 a 本身
void greet(Person p) {
    cout << "Hello " << p.name << endl;
}

int main() {
    Person a("Alice");
    greet(a);  // 这里会调用拷贝构造函数
}
```

- 从函数按值返回对象时。

```cpp
Person makePerson() {
    Person temp("Bob");
    return temp;  // 返回对象副本，会调用拷贝构造函数（或优化）
}

int main() {
    // 这个返回值会被拷贝到主函数中的变量 b
    Person b = makePerson();  // 这里也会调用拷贝构造函数（或优化）
}
```

### 合成拷贝构造函数

在 C++ 中，**合成拷贝构造函数（synthesized copy constructor）**是指编译器自动为一个类生成的拷贝构造函数，用于在对象复制时拷贝成员变量。其形式通常如下：

```cpp
ClassName(const ClassName& other);
```

#### 合成拷贝构造函数的生成条件

编译器会**在没有用户自定义拷贝构造函数**的前提下，自动合成一个拷贝构造函数，前提是：

- 所有成员变量的拷贝构造函数也都是可访问的；
  - 成员的拷贝构造是 `private`
  - 成员的拷贝构造是 `protected`，当前类不是子类或友元 
  - 成员类禁止拷贝（被 `delete`）
  - 私有成员类的拷贝构造是 `private`，但当前类不是它的友元
- 没有被 `= delete` 的特殊成员函数影响（例如：移动构造被删除，可能会影响是否合成等）；

| 成员函数             | 写/删/自定义后影响                 |
| -------------------- | ---------------------------------- |
| 拷贝构造（const T&） | 手写后，编译器不再自动生成移动构造 |
| 移动构造（T&&）      | 手写后，编译器不再自动生成拷贝构造 |
| 删除移动构造         | 拷贝构造仍然可以合成（只要合法）   |
| 删除拷贝构造         | 移动构造仍然可以合成（只要合法）   |

- 类中没有继承或成员是不可复制的对象。

| 类型                            | 是否可复制 | 说明                     |
| ------------------------------- | ---------- | ------------------------ |
| `std::mutex`                    | ❌          | 明确删除了拷贝构造和赋值 |
| 自定义类 `A(const A&) = delete` | ❌          | 手动禁用复制             |
| 继承自不可复制基类              | ❌          | 基类拷贝构造被删除或私有 |
| 含有以上类为成员或基类          | ❌          | 传播不可复制性           |

#### 合成拷贝构造函数的行为

- 对所有**非静态成员变量**执行**逐个拷贝（member-wise copy）**；
- 如果有基类，也会调用**基类的拷贝构造函数**；

示例：

```cpp
struct A {
    int x;
};

struct B {
    A a;
    int y;
    // 编译器会自动生成：
    // B(const B& other) : a(other.a), y(other.y) {}
};

void test() {
    B b1 = { {42}, 7 };
    B b2 = b1;  // 调用合成拷贝构造函数
}
```

#### 与默认关键字 `= default` 的关系

可以显示告诉编译器合成一个：

```cpp
struct C {
    int x;
    C(const C&) = default;  // 明确使用合成版本
};
```

也可以禁用：

```cpp
struct D {
    int x;
    D(const D&) = delete;  // 禁止拷贝构造
};
```

#### 注意事项

- 合成拷贝构造函数是**浅拷贝**，对指针成员变量只拷贝地址，不复制指针所指内容；
- 对于资源管理类（比如类中有 `new` 分配的内存），需要自己定义拷贝构造函数以防止**资源泄漏或双重释放**；
- 在 C++11 之后，如果自定义了**移动构造函数或移动赋值函数**，但没有提供拷贝构造，拷贝构造函数可能不会被自动合成。

#### 默认拷贝构造函数

| 名称             | 定义方式             | 本质行为 | 区别点                   |
| ---------------- | -------------------- | -------- | ------------------------ |
| 合成拷贝构造函数 | 什么都不写           | 浅拷贝   | 编译器隐式生成           |
| 默认拷贝构造函数 | `= default` 明确指定 | 浅拷贝   | 程序员显式要求编译器合成 |

### 自定义拷贝构造函数的典型用途

如果的类中包含**指针**或管理**动态资源（如内存、文件、网络句柄等）**，就应该自定义拷贝构造函数来实现**深拷贝（deep copy）**。

```cpp
class MyArray {
private:
    int* data;
    int size;

public:
    MyArray(int s) : size(s) {
        data = new int[size];
    }

    // 拷贝构造函数 - 深拷贝
    MyArray(const MyArray& other) : size(other.size) {
        data = new int[size];
        for (int i = 0; i < size; ++i)
            data[i] = other.data[i];
    }

    ~MyArray() {
        delete[] data;
    }
};
```

### 使用 `= delete` 禁用拷贝构造函数

如果希望对象**不可拷贝**，可以将拷贝构造函数禁用：

```cpp
class NonCopyable {
public:
    NonCopyable() = default;
    NonCopyable(const NonCopyable&) = delete; // 禁用拷贝构造
};
```

### 避免拷贝构造开销

#### 引用传参

默认传参是「值传递」，会调用拷贝构造函数。但如果用「**引用**」来传递参数，就不会拷贝。

```cpp
class Person {
public:
    string name;
    Person(string n) : name(n) {}

    Person(const Person& other) {
        cout << "拷贝构造函数调用" << endl;
        name = other.name;
    }
};

void greet(const Person& p) {  // 使用 const 引用避免拷贝
    cout << "Hello " << p.name << endl;
}

int main() {
    Person a("Alice");
    greet(a);  // 不会调用拷贝构造函数
}
```

为什么加 `const`？

- 防止函数修改 `a`。
- 允许函数接收临时对象（如 `greet(Person("Temp"))`）。
  - C++ 为了安全性，只允许把临时对象绑定到 `const T&`。
  - 不允许绑定到 `T&（非常量引用）`，因为不能修改临时对象。

#### 移动语义（C++11）

如果一个对象是**临时的**、马上就要销毁了，那就没有必要复制它的资源，而是可以“**移动**”它的资源到新对象中。

```cpp
class MyArray {
public:
    int* data;
    int size;

    MyArray(int s) : size(s) {
        data = new int[size];
        cout << "构造" << endl;
    }

    // 拷贝构造（深拷贝）
    MyArray(const MyArray& other) {
        cout << "拷贝构造" << endl;
        size = other.size;
        data = new int[size];
        for (int i = 0; i < size; ++i)
            data[i] = other.data[i];
    }

    // 移动构造函数（转移资源）
    MyArray(MyArray&& other) noexcept {
        cout << "移动构造" << endl;
        data = other.data;
        size = other.size;
        other.data = nullptr;  // 防止析构时重复释放
        other.size = 0;
    }

    ~MyArray() {
        delete[] data;
    }
};

MyArray createArray() {
    MyArray temp(10);  // 临时对象
    return temp;       // 会触发移动构造
}

int main() {
    MyArray a = createArray();  // 移动构造，而不是拷贝
}
```

移动构造 vs 拷贝构造

| 特性     | 拷贝构造函数           | 移动构造函数（C++11）    |
| -------- | ---------------------- | ------------------------ |
| 参数类型 | `const T&`             | `T&&`（右值引用）        |
| 复制行为 | 分配新资源并复制       | 把资源“转移”给新对象     |
| 性能     | 较慢（复制内容）       | 快（只是转移指针）       |
| 触发条件 | 对临时对象初始化新对象 | 优先触发（如果定义了它） |

### 聚合类型

**聚合类型（Aggregate Type）** 是 C++ 中一种非常特殊的类或结构体类型，它的设计目的就是为了**像数组一样**、**像 C 语言结构体一样**去初始化它 —— 不需要构造函数，不需要成员函数，所有成员按顺序初始化。这种类型在做 POD 类型、性能优化、序列化等低层场景非常有用。

#### 聚合类型的定义（标准描述，C++17）

在 C++17 中，一个**类类型**如果满足以下**所有条件**，就叫做 **聚合类型（aggregate）**：

1. **没有用户声明的构造函数（包括默认构造函数）**
2. **没有私有或受保护的非静态数据成员**
3. **没有虚函数**
4. **没有基类（继承）**
5. **没有使用 `= default` 明确声明的构造函数**
6. **没有虚基类**

从 C++20 起，标准略放宽了一些限制（比如允许 `base class` 也能是 aggregate）。

#### 举例说明

##### 聚合类型

```cpp
struct Point {
    int x;
    int y;
};
```

它是聚合类型，因为：

- 没有构造函数；
- 所有成员都是 public；
- 没有继承；
- 没有虚函数。

它可以用“聚合初始化”：

```cpp
Point p = {1, 2};  // ✅ 聚合初始化（按顺序初始化成员）
```

##### 非聚合类型（有构造函数）

```cpp
struct NotAggregate {
    int x;
    NotAggregate(int val) : x(val) {}
};
```

- 有用户声明的构造函数；
- 所以不是聚合类型；
- 不能 `NotAggregate obj = {1};`。

##### 非聚合类型（有继承）

```cpp
struct Base { int x; };
struct Derived : Base { int y; };  // ❌ 继承了 Base，不是聚合
```

在 **C++17** 中：不是聚合类型（因为继承）
 在 **C++20** 中：是聚合类型（继承被允许）

所以可以这样初始化：

```cpp
Derived d = {{1}, 2};  // 初始化 Base 的 x = 1，Derived 的 y = 2
```

#### 聚合类型的用途

| 用途                          | 说明                                         |
| ----------------------------- | -------------------------------------------- |
| 快速初始化                    | 可以像数组一样用 `{}` 初始化                 |
| 兼容 C 结构体（C 语言互操作） | 和 C 的 `struct` 一样                        |
| 避免构造开销 / constexpr 场景 | 比构造函数快、可以用在低层代码               |
| 标准库中的部分类型也用        | 如 `std::array<T, N>` 是聚合类型（C++20 起） |