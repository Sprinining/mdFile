## 01背包、有依赖的背包

### [P1048 [NOIP2005 普及组] 采药](https://www.luogu.com.cn/problem/P1048)

01背包(模版)

给定一个正数 t，表示背包的容量
有 m 个货物，每个货物可以选择一次
每个货物有自己的体积 costs[i] 和价值 values[i]
返回在不超过总容量的情况下，怎么挑选货物能达到价值最大
返回最大的价值

- 二维 dp 数组

```c++
#include <iostream>
#include <vector>

using namespace std;

int bag(vector<int> &cost, vector<int> &value, int t, int n) {
    // dp[i][j] 表示在前 i 种物品中选择，总代价不超过 j 的情况下，能获得的最大价值
    vector<vector<int>> dp(n + 1, vector<int>(t + 1));
    // 第一行为 0
    fill(dp[0].begin(), dp[0].end(), 0);
    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j <= t; ++j) {
            // 不选 i 号物品，则最大价值和在前 i - 1 个物品中选，总代价不超过 j 的情况下能获得的最大价值一样
            dp[i][j] = dp[i - 1][j];
            // 选 i 号物品，价值就是 i 号物品的价值加上在前 i - 1 个物品中选，总代价不超过 j - cost[i] 的情况下能获得的最大价值
            if (j - cost[i] >= 0)
                dp[i][j] = max(dp[i][j], dp[i - 1][j - cost[i]] + value[i]);
        }
    }
    // 返回在 n 种物品中选择，总代价不超过 t 的情况下，能获得的最大价值
    return dp[n][t];
}

int main() {
    // t 为背包容量，n 为物品种数
    int t, n;
    cin >> t >> n;
    // 物品从 1 编号
    vector<int> cost(n + 1);
    vector<int> value(n + 1);
    for (int i = 1; i <= n; ++i)
        cin >> cost[i] >> value[i];
    cout << bag(cost, value, t, n);
}
```

- 空间压缩

```c++
#include <iostream>
#include <vector>

using namespace std;

int bag(vector<int> &cost, vector<int> &value, int t, int n) {
    // 原矩阵的每一行，逐行往下，第一行为 0
    vector<int> dp(t + 1, 0);
    for (int i = 1; i <= n; ++i) 
        // 如果从左往右的话就需要两个一维数组了，因为从左往右的过程中会覆盖掉 dp[j - cost[i]]
        // 从右往左可以避免这个问题
        // dp[j] 继承自上一行的 dp[j] 不变，表示不选 i 号物品
        // 或者选 i 号物品，价值就是 i 号物品的价值加上在前 i - 1 个物品中选，总代价不超过 j - cost[i] 的情况下能获得的最大价值
        // dp[j - cost[i]] 也来自上一行
        for (int j = t; j - cost[i] >= 0; j--)
            dp[j] = max(dp[j], dp[j - cost[i]] + value[i]);
    // 返回在 n 种物品中选择，总代价不超过 t 的情况下，能获得的最大价值
    return dp[t];
}

int main() {
    // t 为背包容量，n 为物品种数
    int t, n;
    cin >> t >> n;
    // 物品从 1 编号
    vector<int> cost(n + 1);
    vector<int> value(n + 1);
    for (int i = 1; i <= n; ++i)
        cin >> cost[i] >> value[i];
    cout << bag(cost, value, t, n);
}
```

### [bytedance-006. 夏季特惠](https://leetcode.cn/problems/tJau2o/)

```c++
#include <iostream>
#include <vector>

using namespace std;

#define ll  long long

// 返回在 n 种物品中选择，总代价不超过 x 的情况下，能获得的最大价值
ll bag(vector<int> &cost, vector<ll> &value, int x) {
    int n = cost.size() - 1;
    vector<ll> dp(x + 1, 0);
    for (int i = 1; i <= n; ++i)
        for (int j = x; j - cost[i] >= 0; j--)
            dp[j] = max(dp[j], dp[j - cost[i]] + value[i]);
    return dp[x];
}

int main() {
    // x 为预算
    int n, x;
    cin >> n >> x;
    // 待考虑的商品，下标从 1 开始
    vector<int> cost(1);
    // 快乐值
    vector<ll> value(1);
    // 获得的快乐值
    ll res = 0;
    int before, now;
    ll happy;
    for (int i = 1; i <= n; ++i) {
        cin >> before >> now >> happy;
        int val = before - now - now;
        if (val > 0) {
            // 优惠的钱比购买价格还高，一定购买，会使心里预算增加
            x += val;
            res += happy;
        } else {
            cost.emplace_back(-val);
            value.emplace_back(happy);
        }
    }
    cout << res + bag(cost, value, x);
}
```

### [494. 目标和](https://leetcode.cn/problems/target-sum/)

- 暴力递归

```c++
#include <vector>

using namespace std;

class Solution {
public:
    int res;

    // 暴力递归
    void recursive(vector<int> &nums, int target, int curIndex, int sum) {
        if (curIndex == nums.size()) {
            if (sum == target) res++;
            return;
        }
        recursive(nums, target, curIndex + 1, sum + nums[curIndex]);
        recursive(nums, target, curIndex + 1, sum - nums[curIndex]);
    }

    int findTargetSumWays(vector<int> &nums, int target) {
        res = 0;
        recursive(nums, target, 0, 0);
        return res;
    }
};
```

- 带返回值的暴力递归

```c++
#include <vector>

using namespace std;

class Solution {
public:
    int recursive(vector<int> &nums, int target, int curIndex, int sum) {
        if (curIndex == nums.size())
            return sum == target ? 1 : 0;
        return recursive(nums, target, curIndex + 1, sum + nums[curIndex])
               + recursive(nums, target, curIndex + 1, sum - nums[curIndex]);
    }

    int findTargetSumWays(vector<int> &nums, int target) {
        return recursive(nums, target, 0, 0);
    }
};
```

- 记忆化搜索

```c++
#include <iostream>
#include <vector>
#include <unordered_map>

using namespace std;

class Solution {
public:
    unordered_map<int, unordered_map<int, int>> dp;

    // 记忆化搜索版
    // 本来使用 dp[curIndex][sum] 记录，但是 sum 可能是负数
    // 所以用二级哈希表模拟
    int recursive(vector<int> &nums, int target, int curIndex, int sum) {
        if (curIndex == nums.size())
            return sum == target ? 1 : 0;
        if (dp.find(curIndex) != dp.end() && dp[curIndex].find(sum) != dp[curIndex].end())
            return dp[curIndex][sum];
        int res = recursive(nums, target, curIndex + 1, sum + nums[curIndex])
                  + recursive(nums, target, curIndex + 1, sum - nums[curIndex]);
        dp[curIndex].emplace(sum, res);
        return res;
    }

    int findTargetSumWays(vector<int> &nums, int target) {
        return recursive(nums, target, 0, 0);
    }
};
```

- 严格位置依赖的动态规划



- 01 背包



### [1049. 最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/)



### [P1064 [NOIP2006 提高组] 金明的预算方案](https://www.luogu.com.cn/problem/P1064)



### 非负数组前k个最小的子序列累加和